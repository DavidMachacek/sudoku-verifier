package com.ubs.machacek.sudokuverifier.controller

import com.ubs.machacek.sudokuverifier.model.ErrorCode
import com.ubs.machacek.sudokuverifier.model.SudokuException
import io.swagger.annotations.ApiModel
import io.swagger.annotations.ApiModelProperty
import org.apache.logging.log4j.LogManager
import org.apache.logging.log4j.util.Supplier
import org.springframework.http.HttpStatus
import org.springframework.web.bind.annotation.ExceptionHandler
import org.springframework.web.bind.annotation.ResponseStatus
import org.springframework.web.bind.annotation.RestControllerAdvice
import org.springframework.web.multipart.MultipartException
import org.springframework.web.multipart.support.MissingServletRequestPartException
import javax.servlet.http.HttpServletRequest

@RestControllerAdvice
class SudokuAdviceController {

    companion object {
        private val log = LogManager.getLogger(SudokuAdviceController::class.java)
    }

    /**
     * Handles general exception generated by micro-service.
     * In 'real world' one would expect to throw some more general error (e.g. BusinessException), supplied along with this
     * advice exception handler by some external common library, which is shared by the whole ecosystem. Generally you dont
     * want to write your own advice handler for each service.
     */
    @ExceptionHandler(SudokuException::class)
    @ResponseStatus(code = HttpStatus.UNPROCESSABLE_ENTITY)
    fun handleSudokuException(
        e: SudokuException,
        request: HttpServletRequest
    ): ErrorTO {
        return ErrorTO(code = e.errorCode!!, message = e.message).also {
            log.error(Supplier { "receive=[${request.method}]${request.servletPath} , errorCode=${e.errorCode}, message='${e.message}'" })
        }
    }

    /**
     * Handles cases when requested part ('sudoku' part in this case) was not detected inside request
     */
    @ExceptionHandler(MissingServletRequestPartException::class)
    @ResponseStatus(code = HttpStatus.UNPROCESSABLE_ENTITY)
    fun handleMissingServletRequestPartException(
        e: MissingServletRequestPartException,
        request: HttpServletRequest
    ): ErrorTO {
        val errorCode = ErrorCode.SUDOKU_ERR_006_MISSING_FILE
        val errorMessage = "A Sudoku file is required in request's Multipart part 'sudoku'"
        return ErrorTO(code = errorCode, message = errorMessage).also {
            log.error(Supplier { "receive=[${request.method}]${request.servletPath}, errorCode=$errorCode, message='$errorMessage'" })
        }
    }

    /**
     * Handles cases when request is not multipart
     */
    @ExceptionHandler(MultipartException::class)
    @ResponseStatus(code = HttpStatus.UNPROCESSABLE_ENTITY)
    fun handleMultipartException(
        e: MultipartException,
        request: HttpServletRequest
    ): ErrorTO {
        val errorCode = ErrorCode.SUDOKU_ERR_006_MISSING_FILE
        val errorMessage = "Multipart request is required"
        return ErrorTO(code = errorCode, message = errorMessage).also {
            log.error(Supplier { "receive=[${request.method}]${request.servletPath}, errorCode=$errorCode, message='$errorMessage'" })
        }
    }
}

@ApiModel(description = "Single validation error object")
data class ErrorTO(
    @field: ApiModelProperty(
        "Error code to identify occurred error.",
        required = true,
        example = "SUDOKU_ERR_002_INVALID_CHARACTERS",
        dataType = "com.ubs.machacek.sudokuverifier.model.ErrorCode"
    )
    val code: ErrorCode,
    @field: ApiModelProperty(
        "Message briefly describing error and part of sudoku, which caused it. Message is human readable always in english language.",
        required = false,
        example = "Invalidate number inside row [13,1,6,5,2,9,4,8,7]"
    )
    val message: String? = null
)